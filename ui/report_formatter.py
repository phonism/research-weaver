"""
Report formatting and styling module for Research Weaver
Provides professional report formatting with multiple export options
"""
import re
from datetime import datetime
from typing import Optional, Dict, Any


class ReportFormatter:
    """
    Professional report formatter with multiple export formats
    """
    
    def __init__(self):
        self.default_styles = {
            "primary_color": "#1f77b4",
            "secondary_color": "#ff7f0e", 
            "success_color": "#2ca02c",
            "warning_color": "#ff7f0e",
            "danger_color": "#d62728",
            "background_color": "#f8f9fa",
            "border_color": "#dee2e6",
            "text_color": "#212529",
            "link_color": "#0d6efd"
        }
    
    def format_markdown_report(
        self, 
        content: str, 
        title: Optional[str] = None,
        add_metadata: bool = True
    ) -> str:
        """
        Format report with enhanced markdown styling
        """
        formatted_content = content
        
        # Add title if provided
        if title:
            formatted_content = f"# {title}\n\n{formatted_content}"
        
        # Add metadata section
        if add_metadata:
            metadata = self._generate_metadata()
            formatted_content = f"{metadata}\n\n{formatted_content}"
        
        # Enhance section formatting
        formatted_content = self._enhance_sections(formatted_content)
        
        # Improve citation formatting
        formatted_content = self._enhance_citations(formatted_content)
        
        # Add table of contents
        formatted_content = self._add_table_of_contents(formatted_content)
        
        return formatted_content
    
    def format_html_report(
        self, 
        content: str, 
        title: Optional[str] = None,
        theme: str = "professional"
    ) -> str:
        """
        Format report as styled HTML
        """
        # Convert markdown to HTML-like structure
        html_content = self._markdown_to_html(content)
        
        # Get theme CSS
        css_styles = self._get_theme_css(theme)
        
        # Build complete HTML document
        html_template = f"""
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title or 'Research Report'}</title>
    <style>
        {css_styles}
    </style>
</head>
<body>
    <div class="container">
        <header class="report-header">
            <h1 class="main-title">{title or 'Research Report'}</h1>
            <div class="metadata">
                <span class="generated-time">Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</span>
                <span class="generator">Research Weaver</span>
            </div>
        </header>
        
        <main class="report-content">
            {html_content}
        </main>
        
        <footer class="report-footer">
            <p>Generated by Research Weaver - AI-powered multi-agent research system</p>
        </footer>
    </div>
    
    <script>
        {self._get_interactive_js()}
    </script>
</body>
</html>
        """
        
        return html_template.strip()
    
    def _generate_metadata(self) -> str:
        """Generate report metadata section"""
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        metadata = f"""---
**Report Generated:** {current_time}  
**Generator:** Research Weaver  
**Type:** Multi-Agent Research Report  
---"""
        
        return metadata
    
    def _enhance_sections(self, content: str) -> str:
        """Enhance section formatting with better styling"""
        
        # Add icons to common section headers
        section_icons = {
            r"##\s*(Key Findings|ä¸»è¦å‘çŽ°|å…³é”®å‘çŽ°)": "ðŸ” ",
            r"##\s*(Executive Summary|æ‰§è¡Œæ‘˜è¦|æ‘˜è¦)": "ðŸ“‹ ",
            r"##\s*(Market Analysis|å¸‚åœºåˆ†æž)": "ðŸ“Š ",
            r"##\s*(Investment|æŠ•èµ„|æŠ•èµ„æœºä¼š)": "ðŸ’° ",
            r"##\s*(Risk|é£Žé™©|é£Žé™©åˆ†æž)": "âš ï¸ ",
            r"##\s*(Conclusion|ç»“è®º|æ€»ç»“)": "âœ… ",
            r"##\s*(Recommendation|å»ºè®®|æŽ¨è)": "ðŸ’¡ ",
            r"##\s*(References|å‚è€ƒæ–‡çŒ®|å‚è€ƒèµ„æ–™)": "ðŸ“š ",
            r"##\s*(Data|æ•°æ®|æ•°æ®åˆ†æž)": "ðŸ“ˆ ",
            r"##\s*(Trend|è¶‹åŠ¿|è¶‹åŠ¿åˆ†æž)": "ðŸ“‰ "
        }
        
        for pattern, icon in section_icons.items():
            content = re.sub(
                pattern, 
                lambda m: f"## {icon}{m.group(0)[2:].strip()}", 
                content, 
                flags=re.IGNORECASE
            )
        
        # Enhance subsection formatting
        content = re.sub(
            r"^###\s*(.+)$", 
            r"### ðŸ“Œ \1", 
            content, 
            flags=re.MULTILINE
        )
        
        return content
    
    def _enhance_citations(self, content: str) -> str:
        """Enhance citation and reference formatting"""
        
        # Find references section
        ref_patterns = [r'## ðŸ“š References', r'## References', r'## å‚è€ƒæ–‡çŒ®', r'å‚è€ƒæ–‡çŒ®']
        ref_section_start = -1
        
        for pattern in ref_patterns:
            match = re.search(pattern, content, re.IGNORECASE | re.MULTILINE)
            if match:
                ref_section_start = match.start()
                break
        
        if ref_section_start >= 0:
            main_content = content[:ref_section_start]
            ref_section = content[ref_section_start:]
            
            # Enhance reference formatting with better styling
            def format_reference(match):
                ref_num = match.group(1)
                ref_content = match.group(2).strip()
                
                # Extract components
                parts = ref_content.split(' - ')
                if len(parts) >= 3:
                    title = parts[0].strip('*')
                    date = parts[1]
                    source = parts[2]
                    
                    # Format with enhanced styling
                    return f"\n> **[{ref_num}]** **{title}**  \n> ðŸ“… *{date}* | ðŸ”— {source}\n"
                else:
                    return f"\n> **[{ref_num}]** {ref_content}\n"
            
            # Apply enhanced formatting to references
            enhanced_refs = re.sub(
                r'^(\d+)\.\s*(.+)$', 
                format_reference, 
                ref_section, 
                flags=re.MULTILINE
            )
            
            content = main_content + enhanced_refs
        
        return content
    
    def _add_table_of_contents(self, content: str) -> str:
        """Add table of contents based on headers"""
        
        # Extract all headers
        headers = re.findall(r'^(#{2,4})\s*(.+)$', content, re.MULTILINE)
        
        if len(headers) < 3:  # Only add TOC if there are enough sections
            return content
        
        toc_lines = ["## ðŸ“‘ Table of Contents\n"]
        
        for level, title in headers:
            # Clean title (remove icons and extra formatting)
            clean_title = re.sub(r'^[^\w\s\u4e00-\u9fff]+\s*', '', title.strip())
            
            # Create anchor link
            anchor = re.sub(r'[^\w\s\u4e00-\u9fff-]', '', clean_title.lower())
            anchor = re.sub(r'\s+', '-', anchor)
            
            # Determine indentation based on header level
            indent = "  " * (len(level) - 2)
            toc_lines.append(f"{indent}- [{clean_title}](#{anchor})")
        
        toc_lines.append("")  # Empty line after TOC
        
        # Insert TOC after metadata but before first major section
        toc_content = "\n".join(toc_lines)
        
        # Find insertion point (after metadata, before first ## header)
        metadata_end = content.find("---", content.find("---") + 3)
        if metadata_end > 0:
            first_section = content.find("\n## ", metadata_end)
            if first_section > 0:
                return content[:first_section] + "\n\n" + toc_content + content[first_section:]
        
        # Fallback: insert at beginning
        return toc_content + "\n\n" + content
    
    def _markdown_to_html(self, content: str) -> str:
        """Convert markdown-like content to HTML"""
        
        html = content
        
        # Headers
        html = re.sub(r'^# (.+)$', r'<h1>\1</h1>', html, flags=re.MULTILINE)
        html = re.sub(r'^## (.+)$', r'<h2>\1</h2>', html, flags=re.MULTILINE)  
        html = re.sub(r'^### (.+)$', r'<h3>\1</h3>', html, flags=re.MULTILINE)
        html = re.sub(r'^#### (.+)$', r'<h4>\1</h4>', html, flags=re.MULTILINE)
        
        # Bold and italic
        html = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', html)
        html = re.sub(r'\*(.+?)\*', r'<em>\1</em>', html)
        
        # Links
        html = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', r'<a href="\2" target="_blank">\1</a>', html)
        
        # Citations
        html = re.sub(r'\[(\d+)\]', r'<sup class="citation"><a href="#ref-\1">[\1]</a></sup>', html)
        
        # Blockquotes
        html = re.sub(r'^>\s*(.+)$', r'<blockquote>\1</blockquote>', html, flags=re.MULTILINE)
        
        # Lists
        html = re.sub(r'^-\s*(.+)$', r'<li>\1</li>', html, flags=re.MULTILINE)
        html = re.sub(r'(<li>.*</li>)', r'<ul>\1</ul>', html, flags=re.DOTALL)
        
        # Paragraphs
        paragraphs = html.split('\n\n')
        html_paragraphs = []
        
        for para in paragraphs:
            para = para.strip()
            if para and not re.match(r'^<[^>]+>', para):
                html_paragraphs.append(f'<p>{para}</p>')
            else:
                html_paragraphs.append(para)
        
        return '\n\n'.join(html_paragraphs)
    
    def _get_theme_css(self, theme: str) -> str:
        """Get CSS styles for different themes"""
        
        base_css = """
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fff;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .report-header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 3px solid #1f77b4;
        }
        
        .main-title {
            font-size: 2.5em;
            color: #1f77b4;
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .metadata {
            color: #666;
            font-size: 0.9em;
        }
        
        .metadata span {
            margin: 0 15px;
        }
        
        .report-content {
            margin: 40px 0;
        }
        
        h1, h2, h3, h4 {
            margin: 25px 0 15px 0;
            color: #2c3e50;
        }
        
        h1 { font-size: 2.2em; }
        h2 { 
            font-size: 1.8em; 
            padding-left: 10px;
            border-left: 4px solid #1f77b4;
        }
        h3 { 
            font-size: 1.4em;
            color: #34495e;
        }
        h4 { font-size: 1.2em; }
        
        p {
            margin: 15px 0;
            text-align: justify;
        }
        
        .citation {
            color: #1f77b4;
            text-decoration: none;
            font-weight: bold;
        }
        
        .citation:hover {
            background-color: #e6f3ff;
            border-radius: 3px;
            padding: 1px 2px;
        }
        
        blockquote {
            margin: 20px 0;
            padding: 15px 20px;
            background-color: #f8f9fa;
            border-left: 4px solid #1f77b4;
            font-style: italic;
        }
        
        ul {
            margin: 15px 0 15px 30px;
        }
        
        li {
            margin: 8px 0;
        }
        
        a {
            color: #1f77b4;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        .report-footer {
            text-align: center;
            margin-top: 60px;
            padding-top: 30px;
            border-top: 1px solid #dee2e6;
            color: #6c757d;
            font-size: 0.9em;
        }
        
        /* Reference styling */
        div[id^="ref-"] {
            margin-bottom: 15px;
            padding: 12px;
            border-left: 3px solid #1f77b4;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        
        div[id^="ref-"]:target {
            background-color: #fff3cd;
            border-left-color: #ffc107;
            animation: highlight 2s ease-out;
        }
        
        @keyframes highlight {
            0% { background-color: #fff3cd; }
            100% { background-color: #f8f9fa; }
        }
        
        /* Print styles */
        @media print {
            .container {
                max-width: none;
                margin: 0;
                padding: 20px;
            }
            
            .report-header {
                page-break-after: avoid;
            }
            
            h1, h2, h3 {
                page-break-after: avoid;
            }
        }
        """
        
        if theme == "dark":
            base_css += """
            body {
                background-color: #1a1a1a;
                color: #e0e0e0;
            }
            
            .main-title {
                color: #4fc3f7;
            }
            
            h1, h2, h3, h4 {
                color: #f0f0f0;
            }
            
            h2 {
                border-left-color: #4fc3f7;
            }
            
            blockquote {
                background-color: #2d2d2d;
                border-left-color: #4fc3f7;
            }
            
            div[id^="ref-"] {
                background-color: #2d2d2d;
                border-left-color: #4fc3f7;
            }
            """
        
        return base_css
    
    def _get_interactive_js(self) -> str:
        """Get JavaScript for interactive features"""
        return """
        // Smooth scrolling for anchor links
        document.addEventListener('DOMContentLoaded', function() {
            const links = document.querySelectorAll('a[href^="#"]');
            
            links.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href').substring(1);
                    const targetElement = document.getElementById(targetId);
                    
                    if (targetElement) {
                        targetElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });
        });
        """
    
    def generate_export_options(self, content: str, title: str = "Research Report") -> Dict[str, Any]:
        """
        Generate multiple export format options
        """
        
        return {
            "markdown": {
                "content": self.format_markdown_report(content, title),
                "filename": f"{title.replace(' ', '_')}.md",
                "mime_type": "text/markdown"
            },
            "html": {
                "content": self.format_html_report(content, title, "professional"),
                "filename": f"{title.replace(' ', '_')}.html", 
                "mime_type": "text/html"
            },
            "html_dark": {
                "content": self.format_html_report(content, title, "dark"),
                "filename": f"{title.replace(' ', '_')}_dark.html",
                "mime_type": "text/html"
            }
        }